// SPDX-License-Identifier: UNLICENSED

pragma solidity ^0.8.4;

import "@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol";
import '@openzeppelin/contracts/access/Ownable.sol';
import '@chainlink/contracts/src/v0.8/KeeperCompatible.sol';

contract ZoukPunksNFT is ERC721URIStorage, Ownable {
    uint256 public mintPrice;
    uint256 public maxSupply;
    uint256 public maxPerWallet;
    uint256 public totalSupply;
    bool public isPublicMintEnabled;
    string internal baseTokenUri;
    address payable public withdrawWallet;
    mapping(address => uint256) public walletMints;

    // string[] IpfsUri = [
    //     "https://ipfs.io/ipfs/QmXKjE4mx3LgqgSuM4u9C2vzGB6Gv3RUVK9yAywh3ScZTc/1.json",
    //     "https://ipfs.io/ipfs/QmXKjE4mx3LgqgSuM4u9C2vzGB6Gv3RUVK9yAywh3ScZTc/2.json",
    //     "https://ipfs.io/ipfs/QmXKjE4mx3LgqgSuM4u9C2vzGB6Gv3RUVK9yAywh3ScZTc/3.json"
    // ];

    string public baseURI;
    string public baseExtension = ".json";

    uint interval;
    uint lastTimeStamp;

    constructor(string memory uri) payable ERC721('ZoukPunks', 'RP') {
        interval = 30;
        lastTimeStamp = block.timestamp;
        mintPrice = 0.02 ether;
        totalSupply = 0;
        maxSupply = 1000;
        maxPerWallet = 3;
        setBaseURI(uri);
    }

    // fail safe incase the base uri was incorrectly set
    function setBaseURI(string memory _tokenBaseURI) public onlyOwner {
        baseURI = _tokenBaseURI;
    }

    function _baseURI() internal view override returns (string memory) {
        return baseURI;
    }

    modifier onlyAccounts () {
        require(msg.sender == tx.origin, "Not allowed origin");
        _;
    }

    function setBaseExtension(string memory _newBaseExtension) public onlyOwner {
        baseExtension = _newBaseExtension;
    }

    //onlyOwner by default sets the owner as the contract deployer
    function setIsPublicMintEnabled(bool isPubilcMintEntabled_) external onlyOwner {
        isPublicMintEnabled = isPubilcMintEntabled_;
    }

    // url of where the images are located
    function setBaseTokenUri(string calldata baseTokenUri_) external onlyOwner {
        baseTokenUri = baseTokenUri_;
    }

    function tokenURI(uint256 tokenId_) public view override returns (string memory) {
        require(_exists(tokenId_), 'Token does not exist!');
        string memory currentBaseURI = _baseURI();
        return
            bytes(currentBaseURI).length > 0
                ? string(
                    abi.encodePacked(
                        currentBaseURI,
                        Strings.toString(tokenId_),
                        baseExtension
                    )
                )
                : "";
    }

    function withdraw() external onlyOwner {
        (bool success, ) = withdrawWallet.call{ value: address(this).balance }('');
        require(success, 'withdraw failed');
    }

    function mint(uint256 quantity_) public payable {
        require(isPublicMintEnabled, 'minting not enabled');
        require(msg.value == quantity_ * mintPrice, 'wrong mint value');
        require(totalSupply + quantity_ <= maxSupply, 'sold out');
        require(walletMints[msg.sender] + quantity_ <= maxPerWallet, 'exceed max wallet');

        for(uint256 i = 0; i < quantity_; i++) {
            uint256 newTokenId = totalSupply + 1;
            totalSupply++;
            _safeMint(msg.sender, newTokenId);
            // Update your URI!!!
            _setTokenURI(newTokenId, tokenURI(newTokenId));
        }
    }
}

    // function checkUpkeep(bytes calldata /* checkData */) external view returns (bool upkeepNeeded, bytes memory /* performData */) {
    //     upkeepNeeded = (block.timestamp - lastTimeStamp) > interval;
    //     // We don't use the checkData in this example. The checkData is defined when the Upkeep was registered.
    // }

    // function performUpkeep(bytes calldata /* performData */) external {
    //     //We highly recommend revalidating the upkeep in the performUpkeep function
    //     if ((block.timestamp - lastTimeStamp) > interval ) {
    //         lastTimeStamp = block.timestamp;
    //         growFlower(0);
    //     }
    //     // We don't use the performData in this example. The performData is generated by the Keeper's call to your checkUpkeep function
    // }

    // function growFlower(uint256 _tokenId) public {
    //     if (flowerStage(_tokenId) >= 2){return;}
    //     // Get the currrent stage of tghe flower and add 1
    //     uint256 newVal = flowerStage(_tokenId) + 1;
    //     //store the new URI
    //     string memory newUri = IpfsUri[newVal];
    //     // Update the URI
    //     _setTokenURI(_tokenId, newUri);
    // }

    // //determine the stage of the flower growth
    // function flowerStage(uint256 _tokenId) public view returns (uint256) {
    //     string memory _uri = tokenURI(_tokenId);
    //     if (_uri = IpfsUri[0]) { return 0; } 
    //     else if (_uri = IpfsUri[1]) { return 1; } 
    //     else if (_uri = IpfsUri[2]) { return 2; } 
    // }